<img src="https://pic1.zhimg.com/167e1242ed7f9da4c92406eeb0dfabf5_1440w.jpg?source=172ae18b" alt="关于CPU、指令集、架构、芯片的一些科普" style="zoom: 50%;" />



# 2021-12-05

## 架构？指令集？

规范或语言就是指令集 ISA，Instruction Set Architecture  

程序被按照某种指令集的规范翻译为CPU可识别的底层代码的过程叫做编译（compile）

指令集架构

指令集

微架构

X86

X64

X86-64

ARM

复杂指令集

精简指令集

Reduced Instruction Set Computing (RISC) [精简指令集](https://www.zhihu.com/search?q=精简指令集&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A46170108})，比如ARM,MIPS等

Complex Instruction Set Computing (CISC) 复杂指令集，比如Intel的X86等

可变长指令集



架构就像是建楼，按照架构的设计规范可以建造一栋楼，配备了架构设计规范里面的基本配件；

指令集，就是做一件事的流程，执行什么的动作就是执行对应的指令，各种各样的执行动作就构成了一个完整的事件处理系统指令集；

就像在 汇编-51中的各种汇编指令就是一个指令集



微架构就是基于指令集架构以及指令集下的设计的具体功能模块，比如就像是建楼，大楼基于指令集架构，但是具体到具体的户型就可能不一样了，该种户型下可能使用了新材料、新工艺等等，而且面向特定的用户群体，这就像现今的一些芯片的增加的微架构模块；但是归结起来，微架构还是一个实实在在的电路模块，只是这个电路模块有特定的需求与制造工艺等



X86  ： **x86**泛指一系列基于[Intel 8086](https://baike.baidu.com/item/Intel 8086)且向后兼容的[中央处理器](https://baike.baidu.com/item/中央处理器)[指令集架构](https://baike.baidu.com/item/指令集架构)。



X64：



86和64应该说是寄存器的长度



Intel的8086是个寄存器字长16位的芯片，在后续的发展中不断进步，





首先X86和X64一般是指CPU的位数，X64是指CPU是64位版本，X86是指CPU是32位版本。

CPU的位数是指**处理器运算位数**，是指微处理器一次执行指令的数据带宽

CPU位数指的是一个时钟周期内处理器同时寄存和处理的二进制位数

CPU位数 = CPU中寄存器的位数 = CPU一次并行处理的数据宽度。CPU位数越多，则寻址位数越多，处理能力就越强。

CPU寻址能力 = 2^S (s为地址总线宽度） <= CPU位数

操作系统的位数 = 所依赖的指令集位数 <= CPU位数。

整数类型不一定跟位数相等，CPU位数准确地说应该是CPU一次能够并行处理的数据宽度，一般就是指数据总线宽度。





X64准确的说应该叫X86_64，本质上也是X86的一个版本，由于X86已经被淘汰，因此X64就是主流了。



64位系统内存理论最大支持2的64次方即17179869184G，而32位的系统内存最大支持2的32次方即4G，如果安装合计大于4G的内存，32位系统也只能使用4G的大小，多余的空间全部空置。在内存使用高涨的今天，32位系统可以说是跟不上时代的需求了



**操作系统位数**

介绍一个重要的概念“指令集”，指令集可以说是：计算机核心硬件CPU（中央处理器）和 计算机核心软件OS（操作系统)之间的接口、桥梁和纽带。

CPU为了实现其功能都设计了指令集，即CPU的全部指令，这就是机器语言。指令集被整合到了操作系统内核最底层的hal(硬件抽象层)中，属于操作系统与硬件之间(宏指令与微指令)的接口，指令集向操作系统定义了CPU最基本的功能，操作系统调用这些功能让CPU执行某个任务。指令集中的一条指令，就是让CPU完成一系列的动作，而该动作的完成则表明了某种运算的完成。一个功能可能需要一条或几条指令来实现。

**操作系统位数的概念是基于CPU位数的**，且是依赖于指令集的位数的。一般，操作系统位数有如下的关系：

操作系统的位数 = 所依赖的指令集位数 <= CPU位数。

注意：

（1）32位CPU只能安装32位操作系统，32位操作系统支持的内存最多为2的32次方，就是4G；

（2）64位CPU可以安装32位操作系统，也可以安装64位操作系统。64位操作系统的寻址能力就是2的64次方，即理论上是17179869184G，实际中是不可能用到这么大的内存，目前64位windows系统最大只支持128G，而当前主流主板只能加到16G。现在软件兼容性已基本没有任何问题，如果计算机安装内存超过4G，比如到6G或更多，就必须考虑安装64位操作系统，不然发挥不出硬件的所有性能，如内存相当于白装了。



**编译器位数**

这里的编译器位数指的是编译生成的软件的位数。



**处理器指令集架构的宽度和指令的编码长度没有任何关系。不是说64位架构的指令长度为64位。**

**从理论上来讲，指令本身的编码长度越短越好，因为可以节省代码的存储空间。因此即便在64位的架构下，也存在大量16位编码的指令，且基本很少出现过64位的指令编码。**





CPU的基本组成单元即为核心（core）。多个核心可以同时执行多件计算任务，前提是这些任务没有先后顺序。

核心的实现方式被称为微架构（microarchitecture）。微架构的设计影响核心可以达到的最高频率、核心在一定频率下能执行的运算量、一定工艺水平下核心的能耗水平等等



常见的代号如Haswell、Cortex-A15等都是微架构的称号。注意微架构与指令集是两个概念：指令集是CPU选择的语言，而微架构是具体的实现。i7-4770的核心是Haswell微架构，这种微架构兼容x86指令集



微架构研发完成，或者说核心研发完成，接下来就是将其组装为芯片了。过去的芯片仅仅包括CPU部分，如今大量的芯片集成了CPU、GPU、IO等多种不同的功能组件，此时这种芯片就不是传统意义上的“CPU”了。将各种功能组件组装为芯片的技术含量相比微架构研发来说是较低的，因而业界能做此类工作的企业也数量较多。



所谓微架构说白点就是CPU硬件图纸，设计这里有几个晶体管，那里怎么连接晶体管。
核心对应的是逻辑图，是一种逻辑关系，微架构是逻辑关系的硬件实现（把逻辑门转换为硬件设计）。
指令集是机器代码和硬件功能的对应，比如x86的指令集中010110代表把a和b加起来，而arm指令集10011代表把a和b加起来。
编译器，你在电脑上敲的代码a+b是高级语言，x86对应编译器把a+b翻译为a 010110 b，arm编译器则翻译为a 10011 b，然后给对应的CPU看
所谓的soc整合设计，一个芯片，上方放4个A75 cpu 下方放8个mali gpu左边放内存右边放dsp，然后拿塑料片盖上。这叫soc设计



**SIMD**

SIMD(**Single Instruction Multiple Data**)即单指令流多数据流，是一种采用一个控制器来控制多个处理器，同时对一组数据（又称“[数据向量](https://www.zhihu.com/search?q=数据向量&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A55327037})”）中的每一个分别执行相同的操作从而实现空间上的[并行性](https://www.zhihu.com/search?q=并行性&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A55327037})的技术。简单来说就是一个指令能够同时处理多个数据。

<img src="https://pica.zhimg.com/v2-9c786a3bf86c115a7b786a3d1f03e24c_1440w.jpg?source=172ae18b" alt="SIMD简介" style="zoom:33%;" />

<img src="https://pic4.zhimg.com/80/v2-0c56ad7326f03b91fbf48bd0ce5f03ef_720w.jpg" alt="img" style="zoom:50%;" />

使用标量运算一次只能对一对数据执行乘法操作，而采用SIMD[乘法指令](https://www.zhihu.com/search?q=乘法指令&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A55327037})，则一次可以对四对数据同时执行乘法操作。

1996年Intel推出了X86的MMX(MultiMedia eXtension)指令集扩展，MMX定义了8个寄存器，称为MM0到MM7，以及对这些寄存器进行操作的指令。每个寄存器为64位宽，可用于以“压缩”格式保存[64位整数](https://www.zhihu.com/search?q=64位整数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A55327037})或多个较小整数，然后可以将单个指令一次应用于两个32位整数，四个16位整数或8个8位整数。



intel在1999年又推出了全面覆盖MMX的SSE(**Streaming SIMD Extensions， 流式SIMD扩展**)指令集，并

SSE添加了八个新的128位寄存器(XMM0至XMM7)，而后来的X86-64扩展又在原来的基础上添加了8个寄存器(XMM8至XMM15)。SSE支持单个寄存器存储4个[32位单精度浮点数](https://www.zhihu.com/search?q=32位单精度浮点数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A55327037})，之后的SSE2则支持单个寄存器存储2个[64位双精度浮点数](https://www.zhihu.com/search?q=64位双精度浮点数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A55327037})，2个64位整数或4个32位整数或8个16位短整形。SSE2之后还有SSE3，SSE4以及AVX，AVX2等扩展指令集。



AVX引入了16个256位寄存器(YMM0至YMM15)，AVX的256位寄存器和SSE的128位寄存器存在着相互重叠的关系(XMM寄存器为YMM寄存器的低位)，所以最好不要混用AVX与SSE指令集







## GPU计算标准



### OpenCL

**open computing Language**

面向异构计算系统的并行编程标准





### CUDA



**Compute Unified Device  Architecture**

Nvidia显卡的通用并行计算架构









## 并行计算-并行编程

**PVM： parallel virtual machine 并行虚拟机**



### OpenMP

**open-Multi-processing**

<img src="https://img-blog.csdn.net/20180718110944943?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fycm93WUw=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom: 67%;" />

执行模式： 串行-->并行--->串行...

在主线程执行到并行块，并行块还没执行结束是不能执行后续的代码块，需要等待前面的并行块结束才能继续执行



### MPI



**Message-Passing Interface**



# 程序，进程，线程





1)**程序**只是一组指令的有序集合，它本身没有任何运行的含义，它只是一个**静态的实体**。而进程则不同，它是程序在某个数据集上的执行。**进程是一个动态的实体**（**在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体**），它有自己的生命周期。它因创建而产生，因调度而运行，因等待资源或事件而被处于等待状态，因完成任务而被撤消。反映了一个程序在一定的数据集上运行的全部动态过程。



2)**进程和程序并不是一一对应的**，一个程序执行在不同的数据集上就成为不同的进程，可以用进程控制块来唯一地标识每个进程。而这一点正是程序无法做到的，由于程序没有和数据产生直接的联系，既使是执行不同的数据的程序，他们的指令的集合依然是一样的，所以无法唯一地标识出这些运行于不同数据集上的程序。一般来说，一个进程肯定有一个与之对应的程序，而且只有一个。而一个程序有可能没有与之对应的进程(因为它没有执行),也有可能有多个进程与之对应(运行在几个不同的数据集上)。



进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。进程和线程的区别在于：
 简而言之,一个程序至少有一个进程,一个进程至少有一个线程。







进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行**资源分配和调度的一个独立单位。**
 线程是进程的一个实体,是**CPU调度和分派的基本单位，**它是比进程更小的能独立运行的基本单位.

C、C++、Java等语言编写的源程序经相应的编译器编译成可执行文件后，提交给计算机处理器运行。**这时，处在可执行状态中的应用程序称为进程。**从用户角度来看，进程是应用程序的一个执行过程。从操作系统核心角度来看，进程代表的是操作系统分配的内存、CPU时间片等资源的基本单位，是为正在运行的程序提供的运行环境。进程与应用程序的区别在于应用程序作为一个静态文件存储在计算机系统的硬盘等存储空间中，而进程则是处于动态条件下由操作系统维护的系统资源管理实体。多任务环境下应用程序进程的主要特点包括： 
 ●进程在执行过程中有内存单元的初始入口点，并且进程存活过程中始终拥有独立的内存地址空间； 
 ●进程的生存期状态包括创建、就绪、运行、阻塞和死亡等类型； 
 ●从应用程序进程在执行过程中向CPU发出的运行指令形式不同，可以将进程的状态分为用户态和核心态。处于用户态下的进程执行的是应用程序指令、处于核心态下的应用程序进程执行的是操作系统指令。 
 在Unix操作系统启动过程中，系统自动创建swapper、init等系统进程，用于管理内存资源以及对用户进程进行调度等。在Unix环境下无论是由操作系统创建的进程还要由应用程序执行创建的进程，均拥有唯一的进程标识（PID）。 



**颗粒度是指具体的详细和清晰程度。 颗粒度越细，表示细节越详尽，越有助于了解事情的全貌颗粒度越粗，表示细节越少，更多的是抽象概括。**

**下面细说背景**：
 CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。

**一个最最基础的事实**：CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。

**一个必须知道的事实**：执行一段程序代码，实现一个功能的过程介绍  ，当得到CPU的时候，相关的资源必须也已经就位，就是显卡啊，GPS啊什么的必须就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。

**串联起来的事实**：前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：***先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文\*。。。\*。\*

 ========= 重要的东西出现了========**
 进程和线程*就是这样的背景出来的****，两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。\***

- **进程就是包括上下文切换的程序执行时间总和** = **CPU加载上下文+CPU执行+CPU保存上下文**

***线程是什么呢？\***
 进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：

程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。

这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这**里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。

 到此全文结束，再一个总结：**

**进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。**









# **数值计算之 Fortran语言**   

**for mula translator**  公式翻译器

**在与内核底层交互确实是C语言快，但是科学数值计算并不需要过多设计系统内核，所以在数值计算上、Fortran比C更快**













